# LLpkg Store Documentation
## Definitions
### LLpkg
Generated by a toolchain from an _upstream_. An LLpkg essentially represents a collection of bindings for C/C++ dynamic libraries in Go, allowing them to be used like native Go functions.
### Upstream
The provider of binary libraries. Currently only Conan is supported.
### Toolchain
A suite of tools for generating LLpkgs.
## Generation
### Directory Structure
We design a whole new storage structure for llpkg store.
```
+ {LibraryName}
   |
   +-- {NormalGoPkgFiles}
   |    
   +-- llpkg.cfg
   |    
   +-- llcppg.cfg
   |
   +-- .llpkg
         |
         +-- llcppg.symb.json
         |
         +-- llcppg.pub
```
- `llpkg.cfg` declares essential information for llgo module
- `llcppg.cfg` / `llcppg.symb.json` / `llcppg.pub` customize generation behavior in `llcppg` tool
### Version Management
Follow Go's version management for nested modules. Tag `{LibraryName}/{Version}` for each version.

This design is fully compatible with native Go modules, enabling simple installation via:
```bash
llgo get github.com/goplus/llpkg/libcjson@v1.7.18
```
### Reproducible Builds
Standardized methodology for generating compliant, reproducible LLpkgs:
1. Retrieve binaries/headers from upstream and index them into a .pc file
2. Automatically generate LLpkg using the toolchain
3. Debug and re-generate LLpkg by modifying the configuration file
### Publication via GitHub Action
Recommended approach to maintain security and reproducibility:
**Workflow:**
1. Validate configuration files (llpkg.cfg & *.symb.json)
2. Create PR to trigger GitHub Action
3. Review generated LLpkg
4. Merge PR with version tag
**Maintenance:**
- Updates must be published as new versions with -patchX suffix
- Example: `version` -> `version-patch1`

## LLGo Get Usage

Install LLpkg using:
```bash
llgo get clib@cversion
llgo get module_path@module_version
```

1. `clib` corresponds to the original library name in C, and `cversion` corresponds to the original version in C.
2. `llgo get clib`: the module path of the C library needs to be queried from the version mapping table based on clib, which is equivalent to `llgo get module_path@latest` and retrieves the latest llpkg's Go module of clib.
3. Suggestion: Add `llgo clist clib` to inform users of the version mapping information of clib(mapping info is generated based on llpkgstore.json).
  ```
  The available Go module version of this C original version:
  format: c original version => go module versions

  1.3 => ["v0.1.0", "v1.0.1"]
  1.3.1 => ["v1.1.0"]
  ```

Install LLpkg process:

1. `llgo get` follows the Go Module to obtain the corresponding version of the Go module.
2. Check if the pulled Go module contains `llpkg.cfg` to determine if it is a llpkg.
3. If it is, `llgo get` needs to do extra things: 
  - Run `conan install` for binaries and Store `.pc` files for building In LLGOMODCACHE which is an env variable.
  - Add a comment in the `go.mod` file indicating the original version of the corresponding C library for this llpkg and ignore indirect dependence for now.
  ```go.mod
  require (
      github.com/google/llpkg/cjson v1.1.0  // cjson-1.7.18
  )
  ```

## LLGOMODCACHE Env Variable Design

One usage is to store `.pc` files of the C library and allow `llgo build` to find them

1. Initialized as `${GOPATH}/llgo/pkg/mod`
2. if GOPATH is empty, it defaults to `${HOME}/llgo/pkg/mod`
3. `{LLGOMODCACHE}/{module_path}/{module_name}@{module_version}/` stores a binary `.pc` file of the C library corresponding to the Go Module

```
llgo get cjson@1.7.18

module_path: github.com/goplus/llpkg
module_name: cjson
module_version: v1.1.0, mapping C library 1.7.18 to the corresponding Go Module version according to the version mapping table
```

## Version Conversion Rules [wip]

There are two methods for converting versions:

### 1. Conversion by a formula

1. **Semver-compliant versions**: Use directly
   - Example: 2.1.5 → 2.1.5
2. **Non-Semver versions**: Convert using pattern:
   ``` 
   0.0.0-0-{original_version}
   ```
   Conversion steps:
   1. Replace dots with hyphens
   2. Append `0-` prefix
   Examples:
   - `2023Q4 → 0.0.0-0-2023Q4`
   - `2023.07.05 → 0.0.0-0-2023-07-05`
   - `0067 → 0.0.0-0-0067`

### 2. Conversion by mapping

#### Semver Bumping Rules

**Initial Version**

  If the C package is stable, then start with `v1.0.0`; Otherwise, start with `v0.1.0`.
  
**Bumping Rules**

  We don't have to obey the original version's bump due to the original version may not follow the SemVer rules.
  - MAJOR version bump: When the C library has made incompatible API changes (MAJOR).
  - MINOR version bump: When the C library has added functionality in a backwards-compatible manner (MINOR), or it has backward compatible bug fixes (**PATCH**). For example, the original version is `v1.0.0`, and the new version would be `v1.1.0`.
  - PATCH version bump: When we found a bug in the previous llpkg (**Not Related to the C library**), we will bump the patch version.
  - Pre-release versions of C library like `v1.2.3-beta.2` would not be accepted.
  - **Note**: Please note that the version number of the llpkg is **not related** to the version number of the C library. The PATCH update of the c library will be the MINOR update of the llpkg, as the PATCH update of the llpkg is related to llpkg bug fixes.

#### Mapping File Structure

We have designed the following files for mapping query conversion version numbers.

`llpkgstore.json`:

```json
{
    "cgood": {
        "versions" : [{
            "original": "1.3",
            "converted": ["v0.1.0", "v1.0.1"]
        }, 
        {
            "original": "1.3.1",
            "converted": ["v1.1.0"]
        }]
    }
}
```

- `original` represents the original C library version number.
- `converted` represents the converted version numbers.

The relationship between the original C library version number and the converted version numbers is one-to-many, mainly due to the need to regenerate the llcppg updates.

`llgo get` is expected to select the largest version from the `converted` field.

#### Web Service

The main purpose is to provide a download of the mapping table.

- **llpkg.goplus.org**

This domain is hosted by GitHub Pages, and the `llpkgstore.json` file is located in the same branch as GitHub Pages.

When running `llgo get`, it will download the file to the local `LLGOMODCACHE` directory.

`LLGOMODCACHE` is an environment variable.

### 3. Comparison

Related discussions: https://github.com/semver/semver/issues/522

#### Formula

**Advantages**:

1. Distributable and Decentralized

2. Fully Automated

3. Simpler Engineering

**Disadvantages**:

1. Difficult to Define

2. Lacks Semantic Meaning

#### Mapping

**Advantages**:

1. Highly Customizable

2. Precise Representation: It can be meticulously defined to represent specific API modifications.

**Disadvantages**:

1. Requires Manual Intervention: Version numbers must be determined manually, making it impossible to fully automate.

2. Centralized Maintenance: A mapping service must be maintained, which prevents decentralization.

## Configuration
### llpkg.cfg Structure
```json
{
  "package": {
    "name": "cjson",
    "version": "1.7.18"
  },
  "upstream": {
    "name": "conan",
    "config": {
      "generator": "cmake",
      "options": ""
    }
  },
  "toolchain": {
    "name": "llcppg",
    "version": "0.9.7",
    "config": {
      "trimPrefixes": []
    }
  }
}

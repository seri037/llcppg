# llpkgstore documentation

## Directory structure

```
+ {CLibraryName}
   |
   +-- {NormalGoModuleFiles}
   |
   +-- llpkg.cfg
   |    
   +-- llcppg.cfg
   |
   +-- llcppg.symb.json
   |
   +-- llcppg.pub
   |
   +-- demo
```

- `llpkg.cfg`: definition of an llpkg's generation workflow
- `llcppg.cfg`, `llcppg.symb.json`, `llcppg.pub`: config files of `llcppg`

## llpkg.cfg structure

```json
{
  "package": {
    "name": "cjson",
    "version": "1.7.18"
  },
  "upstream": {
    "name": "conan",
    "config": {
      "generator": "cmake",
      "options": ""
    }
  },
  "toolchain": {
    "name": "llcppg",
    "version": "0.9.7",
    "config": {
      "trimPrefixes": []
    }
  }
}
```

- `package`: 

  Generated by a toolchain from an upstream. An llpkg essentially represents a collection of bindings for C/C++ dynamic libraries in Go, allowing them to be used like native Go functions.

- `upstream`: 

  The provider of binary libraries. Currently only Conan is supported.

- `toolchain`: 

  A suite of tools for generating llpkgs.

## Getting an llpkg

Use `llgo get` to get an llpkg:

```bash
llgo get clib@cversion
```

*e.g.* `llgo get cjson@1.7.18`

- `clib`: the original library name in C
- `cversion`: the original version in C

`llgo` automatically handles two things:

1. Prepends required prefixes to `clib` references, converting them into valid `module_path` identifiers.
2. Convert `cversion` to canonical `module_version` using the mapping table.

Or you can use `llgo` with go module syntax directly:

```bash
llgo get module_path@module_version
```

*e.g.* `llgo get github.com/goplus/llpkg/cjson@v1.0.0`

`latest` identifier is also supported as a valid `cversion` or `module_version`. `llgo` will choose the latest version of the llpkg.

> **Details of `llgo get`**
>
>  1. `llgo` automatically resolves `clib@cversion` syntax into canonical `module_path@module_version` format.
>  2. Pull the go module by `go get`.
>  3. Check `llpkg.cfg` to determine if it's an llpkg. If it is:
>
>   - Run `conan install` to install binaries. `.pc` files for building will be stored in `${LLGOMODCACHE}`.
>   - Indicate the original `cversion` by adding a comment in `go.mod`. (We ignore indirect dependencies for now.)
>
>    ```go.mod
>    require (
>        github.com/goplus/llpkg/cjson v1.1.0  // cjson 1.7.18
>    )
>    ```

### Listing all versions [wip]

Suggestion: Add `llgo list clib -versions` to provide user the version mapping of an llpkg. 

```
// cversion => module_version

1.3 => ["v0.1.0", "v1.0.1"]
1.3.1 => ["v1.1.0"]
```

## Publication via GitHub Action

**Workflow**

1. Create PR to trigger GitHub Action
2. PR verification
3. llpkg generation
4. Run test
5. Review generated llpkg
6. Merge PR
7. Add a version tag by gha on main branch

**PR Verification Workflow**  
1. Ensure that there is only one `llpkg.cfg` file across all directories. If multiple instances of `llpkg.cfg` are detected, the PR will be aborted.  
2. Check if the directory name is valid.

**llpkg Generation**

A standard method for generating valid llpkgs:
1. Receive binaries/headers from upstream, and index them into `.pc` files
2. Automatically generate llpkg using a toolchain
3. Debug and re-generate llpkg by modifying the configuration file

**Version Tag Rule**
1. Follow Go's version management for nested modules. Tag `{CLibraryName}/{MappingVersion}` for each version.
2. This design is fully compatible with native Go modules
    ```
    github.com/goplus/llpkg/cjson@v1.7.18
    ```

**Legacy Version Maintenance Workflow**  

When GitHub Actions detect that the current PR is for maintenance:  

- Verify if there are existing `MAJOR` and `MINOR` CLib versions.  
- Ensure the version in the PR does not exceed the current version. If it does, the PR will be aborted. (Refer to the [Branch Maintenance Strategy](#conversion-by-mapping) for details.)  
- If the maintenance version is lower than the `main` branch version, optionally check for an existing branch corresponding to the version; if none exists, create one. Then, update the base branch of the maintenance PR accordingly.   
- Regenerate the module and merge with new patch tag.

Example:
Suppose we are maintaining the `clib@1.5.2` package, while the latest version in the `main` branch of `clib` is `1.6`.  

In this case:  

- GitHub Actions **SHOULD** create a new branch from the `1.5.2` tag.  
- The base branch of the PR will then be updated to the newly created branch (not the `main` branch).  

This ensures the maintenance PR is aligned with the correct version instead of the latest one in the `main` branch.

## Version conversion rules [wip]

We use a mapping table to convert C library versions to llpkg versions.

### Initial version

If the C library is stable, then start with `v1.0.0` (cjson@1.7.18)
  
Otherwise, start with `v0.1.0`, until it releases a stable version. (libass@0.17.3)
  
### Bumping rules

| Component | Trigger Condition | Example |
|-----------|--------------------|---------|
| **MAJOR** | Breaking changes introduced by upstream C library updates. | `cjson@1.7.18` → `1.0.0`, `cjson@2.0` → `2.0.0` |
| **MINOR** | Non-breaking upstream updates (features/fixes). | `cjson@1.7.19` (vs `1.7.18`) → `1.1.0`; `cjson@1.8.0` → `1.2.0` |
| **PATCH** | llpkg internal fixes **unrelated** to upstream changes, or upstream patches on history versions (see [this](#prohibition-of-legacy-patch-maintenance)). | `llpkg@1.0.0` → `1.0.1` |

- Currently, we only consider C library updates since the first release of an llpkg.
- Pre-release versions of C library like `v1.2.3-beta.2` would not be accepted.
- **Note**: Please note that the version number of the llpkg is **not related** to the version number of the C library. It's the llpkg's MINOR update that corresponds to the C library's PATCH update, while the llpkg's PATCH update is used for indicating llpkg's self-updating.

### Branch maintenance strategy

#### Context

- Existing repository tracks upstream `cjson@1.6` with historical versions: `cjson@1.5.7`, `cjson@1.5.6`, `cjson@1.6`.  
- Upstream releases `1.5.8` targeting older `1.5.x` series.

#### Rule

`1.5.8` **cannot** be merged into `main` branch (currently tracking `1.6`). Instead, we should create a new branch `release-branch.cjson/v1.5` and commit to it.

### Prohibition of legacy patch maintenance

#### Problem

| C Library Version | llpkg Version | Issue |
|--------------------|---------------|-------|
| 1.5.1             | `1.0.0`       | Initial release |
| 1.5.1 (llpkg fix) | `1.0.1`       | Patch increment |
| 1.6               | `1.1.0`       | Minor increment |
| 1.5.2             | ?             | Conflict: `1.1.0` already allocated |

If we increment PATCH to `1.0.2` to represent `cjson@1.5.2`:

| C Library Version | llpkg Version | Issue |
|--------------------|---------------|-------|
| 1.5.1             | `1.0.0`       | Initial release |
| 1.5.1 (llpkg fix) | `1.0.1`       | Patch increment |
| 1.6               | `1.1.0`       | Minor increment |
| 1.5.2             | `1.0.2`       | Conflict: `1.1.0` already allocated |
| 1.5.1 (llpkg fix 2) | `1.0.3`       | Patch increment |

`cjson@1.5.2` > `cjson@1.5.1` maps to `llpkg@1.0.2` < `llpkg@1.0.3` (breaking version ordering), which causes MVS to prioritize `1.0.3` (lower priority upstream version) over `1.0.2`.

#### Conflict resolution rule

When upstream releases patch updates for **previous minor versions**:
- NO further patches shall be applied to earlier upstream patch versions
- ALL maintenance MUST target the **newest upstream patch version**

#### Rationale

New patch updates from upstream naturally replace older fixes. Keeping old patch versions creates unnecessary differences that don't align with SemVer principles **and may leave security vulnerabilities unpatched**.

#### Workflow

- cjson@1.5.8 released → llpkg MUST update from latest 1.5.x baseline (1.5.7)
- Original cjson@1.5.1 branch becomes immutable

### Mapping file structure

`llpkgstore.json`:

```json
{
    "cgood": {
        "versions" : [{
            "c": "1.3",
            "go": ["v0.1.0", "v1.0.1"]
        }, 
        {
            "c": "1.3.1",
            "go": ["v1.1.0"]
        }]
    }
}
```

- `c` represents the original C library version number.
- `go` represents the converted version numbers.

The relationship between the original C library version number and the mapping version numbers is one-to-many, mainly due to the need to regenerate the llcppg updates.

`llgo get` is expected to select the largest version from the `go` field.

## Web service

1. provide a download of the mapping table.
2. provide a version query of the Go Module corresponding to the C library.

**llpkg.goplus.org**

This domain is hosted by GitHub Pages, and the `llpkgstore.json` file is located in the same branch as GitHub Pages.When running `llgo get`, it will download the file to the local `LLGOMODCACHE` which is an environment variable.

## `LLGOMODCACHE`

One usage is to store `.pc` files of the C library and allow `llgo build` to find them.

1. if `LLGOMODCACHE` is empty, it defaults to `${HOME}/llgo/pkg/mod`.
2. `{LLGOMODCACHE}/{module_path}@{module_version}/pkg-config` stores `.pc` files of C libs needed by llpkg.